// Copyright 2025 Palantir Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package plugins

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/palantir/godel/v2/framework/artifactresolver"
	"github.com/palantir/godel/v2/framework/builtintasks/installupdate/layout"
	"github.com/palantir/godel/v2/framework/godel/config"
	"github.com/palantir/godel/v2/framework/godellauncher"
	"github.com/palantir/godel/v2/framework/pluginapi/v2/pluginapi"
	"github.com/palantir/pkg/specdir"
	"github.com/pkg/errors"
)

// locatorFromString returns the artifactresolver.Locator created by parsing the provided string, which must be in the
// format "<group>:<product>:<version>" (the format used by the String() function for a artifactresolver.Locator).
func locatorFromString(s string) (artifactresolver.Locator, error) {
	parts := strings.Split(s, ":")
	if len(parts) != 3 {
		return artifactresolver.Locator{}, errors.Errorf("invalid locator format: %s", s)
	}
	return artifactresolver.Locator{
		Group:   parts[0],
		Product: parts[1],
		Version: parts[2],
	}, nil
}

// marshalPluginsInfoJSON returns the JSON representation of the provided plugins map. The returned bytes can be
// converted back to a plugins map using the unmarshalPluginsInfoJSON function.
func marshalPluginsInfoJSON(plugins map[artifactresolver.Locator]pluginInfoWithAssets) ([]byte, error) {
	outMap := make(map[string]marshalPluginInfoWithAssetsType)
	for k, v := range plugins {
		outMap[k.String()] = marshalPluginInfoWithAssetsType{
			PluginInfo: marshalPluginInfoType{
				PluginInfo: v.PluginInfo,
			},
			Assets: v.Assets,
		}
	}
	return json.Marshal(outMap)
}

// unmarshalPluginsInfoJSON takes the JSON representation of a plugins map and returns the original map. The input bytes
// must have been generated by the marshalPluginsInfoJSON function.
func unmarshalPluginsInfoJSON(data []byte) (map[artifactresolver.Locator]pluginInfoWithAssets, error) {
	var outMap map[string]marshalPluginInfoWithAssetsType
	if err := json.Unmarshal(data, &outMap); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal plugin information")
	}
	plugins := make(map[artifactresolver.Locator]pluginInfoWithAssets)
	for k, v := range outMap {
		locator, err := locatorFromString(k)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to parse plugin locator from string: %s", k)
		}
		plugins[locator] = pluginInfoWithAssets{
			PluginInfo: v.PluginInfo.PluginInfo,
			Assets:     v.Assets,
		}
	}
	return plugins, nil
}

// marshalPluginInfoWithAssetsType exists to allow for JSON marshalling and unmarshalling of the pluginInfoWithAssets
// struct. The type of the "PluginInfo" field of pluginInfoWithAssets is pluginapi.PluginInfo, which cannot be JSON
// marshalled directly, so this struct uses the marshalPluginInfoType to represent that field.
type marshalPluginInfoWithAssetsType struct {
	PluginInfo marshalPluginInfoType      `json:"pluginInfo"`
	Assets     []artifactresolver.Locator `json:"assets"`
}

// marshalPluginInfoType is a wrapper struct around pluginapi.PluginInfo to allow for JSON marshalling and
// unmarshalling. It provides implementations of the MarshalJSON and UnmarshalJSON methods that uses custom logic to
// marshal and unmarshal the pluginapi.PluginInfo type. It is safer to do this using a custom struct than to add these
// methods to the pluginapi.PluginInfo interface directly because the unmarshal needs to handle different concrete
// types and because making those methods part of the interface would prevent implementors of the interface from having
// their own custom marhsal/unmarshal logic.
type marshalPluginInfoType struct {
	PluginInfo pluginapi.PluginInfo
}

func (m marshalPluginInfoType) MarshalJSON() ([]byte, error) {
	return m.PluginInfo.MarshalPluginInfoJSON()
}

func (m *marshalPluginInfoType) UnmarshalJSON(data []byte) error {
	pluginInfo, err := pluginapi.UnmarshalPluginInfoJSON(data)
	if err != nil {
		return errors.Wrapf(err, "failed to unmarshal plugin info")
	}
	m.PluginInfo = pluginInfo
	return nil
}

func (p pluginInfoWithAssets) MarshalJSON() ([]byte, error) {
	return json.Marshal(marshalPluginInfoWithAssetsType{
		PluginInfo: marshalPluginInfoType{
			PluginInfo: p.PluginInfo,
		},
		Assets: p.Assets,
	})
}

func (p *pluginInfoWithAssets) UnmarshalJSON(data []byte) error {
	var marshalPluginInfoWithAssets marshalPluginInfoWithAssetsType
	if err := json.Unmarshal(data, &marshalPluginInfoWithAssets); err != nil {
		return errors.Wrapf(err, "failed to unmarshal plugin info with assets")
	}
	p.PluginInfo = marshalPluginInfoWithAssets.PluginInfo.PluginInfo
	p.Assets = marshalPluginInfoWithAssets.Assets
	return nil
}

// LoadPluginsTasksWithCache loads the plugin tasks and upgrade tasks for the provided plugins config.
// This function is the equivalent of LoadPluginsTasks but uses a cache file to retrieve and store the plugin
// information.
//
// Using a cache is motivated by the fact that the "LoadPluginsTasks" function can be relatively expensive to call
// because the "resolvePlugins" function potentially computes the checksum of all plugins and assets (which requires
// reading and computing a checksum of all plugin and asset files) and also invokes all the plugin binaries to parse
// their information. For a godel installation with a representative number of plugins and assets, this operation can
// take around 250ms. Although this may not be a long time on an absolute scale, it is long enough to feel like a pause
// to the user when invoking the CLI, and this cost is incurred on every invocation of the CLI. The godel configuration
// for a given project is also relatively stable (the number and frequency of changes to the configuration is orders of
// magnitude less than the number of times the CLI is invoked), so there will also typically be many more cache hits
// than misses, which makes this ideal information to cache.
//
// The cache file is determined by the SHA256 checksum of the JSON representation of the plugins config. The provided
// PluginsParam should be the result of calling "ToParam()" on the provided PluginsConfig. Note that the name of the
// cache file is based on the checksum of the plugins configuration, but its content is the JSON representation of the
// plugins map used to compute the result of this function (so the checksum of the content will not match the name of
// the file).
//
// The current design keys the cache content only on the plugins configuration. This means, that if the logic of godel
// itself changes in a manner such that a given plugin configuration would produce different plugin information, the
// cached information would not be correct. In such a scenario, the naming scheme for the cache files would need to be
// updated to ensure that invalid cache information is not used. Namespacing the cache files by the version of godel
// would be one way of protecting against this, but given that the logic for computing the plugin information is very
// stable (it has not changed in over 9 years), it is unlikely to be an issue (and in such a circumstance, changing the
// naming scheme of the cache to add some kind of schema prefix or suffix or as a parent directory should be a
// sufficient solution).
func LoadPluginsTasksWithCache(pluginsConfig config.PluginsConfig, pluginsParam godellauncher.PluginsParam, stdout io.Writer) ([]godellauncher.Task, []godellauncher.UpgradeConfigTask, error) {
	configBytes, err := json.Marshal(pluginsConfig)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to marshal plugins config as JSON")
	}
	pluginsConfigCachePath, err := cacheFilePathForBytes(configBytes)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to create plugins config cache file path")
	}
	return loadPluginsTasks(pluginsParam, stdout, pluginsConfigCachePath)
}

// Returns the path to the plugins-config cache file for the provided data. The path to the directory for the file is
// created if it does not already exist. The file name is the hex-encoded SHA256 checksum of the data with a ".json"
// suffix appended to it.
func cacheFilePathForBytes(data []byte) (string, error) {
	pluginsConfigCacheBasePath, err := pluginsConfigCacheDir()
	if err != nil {
		return "", err
	}
	checksum := sha256.Sum256(data)
	return filepath.Join(pluginsConfigCacheBasePath, hex.EncodeToString(checksum[:])+".json"), nil
}

// Returns the path to the plugins-config cache directory. The path to the directory is created if it does not exist.
func pluginsConfigCacheDir() (string, error) {
	godelHomeSpecDir, err := layout.GodelHomeSpecDir(specdir.Create)
	if err != nil {
		return "", errors.Wrapf(err, "failed to create g√∂del home directory")
	}
	cacheDir := godelHomeSpecDir.Path(layout.CacheDir)
	pluginsConfigPath := filepath.Join(cacheDir, "plugins-config", "v1")
	if err := os.MkdirAll(pluginsConfigPath, 0755); err != nil {
		return "", errors.Wrapf(err, "failed to create plugins-config cache directory at %q", pluginsConfigPath)
	}
	return pluginsConfigPath, nil
}

// writeFileUsingRename ensures that the file at the provided path has the provided data in a concurrency-safe manner. The
// parent directory of the provided path must already exist. It does this by writing the content to a unique temporary
// file in the same directory and then renaming it to the provided path.
func writeFileUsingRename(cachePath string, data []byte) error {
	tmpCacheFile, err := os.CreateTemp(filepath.Dir(cachePath), fmt.Sprintf("%s-*", filepath.Base(cachePath)))
	if err != nil {
		return errors.Wrapf(err, "failed to create temporary cache file")
	}
	if _, err := tmpCacheFile.Write(data); err != nil {
		return errors.Wrapf(err, "failed to write cache file")
	}
	if err := tmpCacheFile.Close(); err != nil {
		return errors.Wrapf(err, "failed to close cache file")
	}
	if err := os.Rename(tmpCacheFile.Name(), cachePath); err != nil {
		return errors.Wrapf(err, "failed to rename cache file")
	}
	return nil
}
