// Copyright 2016 Palantir Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package clean

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/pkg/errors"

	"github.com/palantir/distgo/distgo"
)

func Products(projectInfo distgo.ProjectInfo, projectParam distgo.ProjectParam, productIDs []distgo.ProductID, dryRun bool, stdout io.Writer) error {
	productParams, err := distgo.ProductParamsForProductArgs(projectParam.Products, productIDs...)
	if err != nil {
		return err
	}
	for _, productParam := range productParams {
		if err := Run(projectInfo, productParam, dryRun, stdout); err != nil {
			return errors.Wrapf(err, "failed to clean %s", productParam.ID)
		}
	}
	return nil
}

type pathInfo struct {
	// path to the "root" output directory
	rootDir string
	// true if this path is a directory, false if it is a file
	isDir bool
}

// Run cleans the outputs generated by the specified product (and its dependencies).
func Run(projectInfo distgo.ProjectInfo, productParam distgo.ProductParam, dryRun bool, stdout io.Writer) error {
	// map of paths to remove. Value is true if currPath is a directory, false otherwise.
	removePaths := make(map[string]pathInfo)
	for _, currProductParam := range productParam.AllProductParams() {
		outputInfo, err := distgo.ToProductTaskOutputInfo(projectInfo, currProductParam)
		if err != nil {
			return err
		}

		// add build directory for product for removal
		if currProductParam.Build != nil {
			removePaths[path.Dir(outputInfo.ProductBuildOutputDir())] = pathInfo{
				rootDir: projectInfo.ProjectDir,
				isDir:   true,
			}
		}

		// add dist directory for product for removal
		if currProductParam.Dist != nil {
			for distID := range currProductParam.Dist.DistParams {
				removePaths[path.Dir(path.Dir(outputInfo.ProductDistOutputDir(distID)))] = pathInfo{
					rootDir: projectInfo.ProjectDir,
					isDir:   true,
				}
			}
		}
	}

	var sortedPaths []string
	for k := range removePaths {
		sortedPaths = append(sortedPaths, k)
	}
	sort.Strings(sortedPaths)

	if dryRun {
		distgo.DryRunPrintln(stdout, fmt.Sprintf("Clean %s will remove paths:", productParam.ID))
	}

	// stores all of the paths that were removed/marked for removal
	removedPaths := make(map[string]struct{})
	for _, currPath := range sortedPaths {
		pathInfo := removePaths[currPath]
		if dryRun {
			distgo.DryRunPrintln(stdout, fmt.Sprintf("    %s", currPath))
		} else {
			// if target path exists, attempt to remove it
			if _, err := os.Stat(currPath); err == nil {
				if pathInfo.isDir {
					if err := os.RemoveAll(currPath); err != nil {
						return errors.Wrapf(err, "failed to remove directory %s", currPath)
					}
				} else {
					if err := os.Remove(currPath); err != nil {
						return errors.Wrapf(err, "failed to remove file %s", currPath)
					}
				}
			}
		}
		removedPaths[currPath] = struct{}{}

		// verify that current path is direct descendant of root directory
		if !strings.Contains(currPath, pathInfo.rootDir) {
			return errors.Errorf("root dir path %s does not occur in %s", pathInfo.rootDir, currPath)
		}

		// for each parent directory between the removed path and the root, check if removal caused it to become empty.
		// If so, remove it and continue the process.
		currParentDir := currPath
		for {
			currParentDir = path.Dir(currParentDir)
			if currParentDir == pathInfo.rootDir {
				break
			}
			if _, err := os.Stat(currParentDir); os.IsNotExist(err) {
				// nothing to do if parent directory does not exist
				break
			}
			removed, err := removeDirIfEmpty(currParentDir, removedPaths, dryRun)
			if err != nil {
				return err
			}
			if !removed {
				// if there was no error and directory was not removed, nothing more to do
				break
			}
			if dryRun {
				distgo.DryRunPrintln(stdout, fmt.Sprintf("    %s", currParentDir))
			}
		}
		// remove root directory if it is now empty
		rootDirRemoved, err := removeDirIfEmpty(pathInfo.rootDir, removedPaths, dryRun)
		if err != nil {
			return err
		}
		if rootDirRemoved && dryRun {
			distgo.DryRunPrintln(stdout, fmt.Sprintf("    %s", pathInfo.rootDir))
		}
	}
	return nil
}

// Removes the given path (which must be a directory) if it exists and is empty. Returns true if the directory was
// removed, false otherwise. Returns an error if the provided path was not a directory of if there was an error reading
// or removing it.
func removeDirIfEmpty(dirPath string, removedPaths map[string]struct{}, dryRun bool) (bool, error) {
	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		return false, nil
	}
	dirFiles, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return false, errors.Wrapf(err, "failed to read directory: %s", dirPath)
	}

	// if this is a dry run, determine the files that "should" exist
	if dryRun {
		var dryRunDirFiles []os.FileInfo
		for _, currDirFile := range dirFiles {
			if _, ok := removedPaths[path.Join(dirPath, currDirFile.Name())]; ok {
				// path is a path marked for removal: do not consider it
				continue
			}
			dryRunDirFiles = append(dryRunDirFiles, currDirFile)
		}
		dirFiles = dryRunDirFiles
	}

	if len(dirFiles) != 0 {
		// if directory contains files, nothing to do: do not remove
		return false, nil
	}

	if !dryRun {
		// if this is not a dry run, actually perform the removal
		if err := os.RemoveAll(dirPath); err != nil {
			return false, errors.Wrapf(err, "failed to remove directory %s", dirPath)
		}
	}

	removedPaths[dirPath] = struct{}{}
	return true, nil
}
